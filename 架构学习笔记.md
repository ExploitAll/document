## 架构设计的原则

### 1，简单

### 2，合适

### 3，演化

## 架构复杂度的来源

### 1，高性能

#### 1.1 高性能数据库集群

##### 1.1.1 读写分离

###### 1.1.1.1  原理

​		数据库读写分离的基本原理是将数据库的读写操作分散到不同的节点上，下面是具体的示例图。

![image-20210130170105621](C:\Users\pblov\AppData\Roaming\Typora\typora-user-images\image-20210130170105621.png)

###### 1.1.1.2	实现

- ​	数据库服务器搭建主从集群，一主一从或者一主多从都可以。
- ​    数据库主机负责读写操作，从机只负责读操作。
- ​    数据库主机通过主从复制模式将数据复制到从服务器上从而保证了每台数据库服务器上都保留了所有的业务数据。
- ​    业务服务器一般可以将写操作发送给主机，读操作默认发送给从机，特殊情况下读操作也可以发送给主机。

###### 1.1.1.3   注意事项

- 主从复制延迟

  ​		如果数据量比较大，数据库主从复制需要的时间也会比较长，所以可能会出现，用户调用一个接口通过主节点写入数据后，再通过备节点无法查询出来数据的情况。这种情况下通常会有如下几种解决方案。

  1. 写操作后的读取操作需要指定发送给特定的主节点。

     ​		这种方案与业务强绑定，对于业务代码的侵入与影响更大。

  2. 从节点读取失败后再从主节点重新读取一遍数据。

     ​		这种方案与业务无绑定，实现的代价小，但是如果系统有很多的二次访问会加大主节点的访问压力。

  3. 关键业务的读写操作全部发送到主节点，非关键业务的读写操作进行分离。



###### 1.1.1.4	读写分配

1. 程序代码封装

   ​		在代码中抽象出来一个数据访问层来实现读写操作的分离与数据库连接的管理。但是这样操作往往会有如下的特点。

   - 实现简单，可以根据业务进行更多的定制化。

   - 与编程语言强耦合，每一种编程语言都需要开发一套单独的数据库访问层来实现读写分离。

   - 故障情况下，如果发生主从切换可能需要所有的系统重新配置并重启。

     淘宝的TDDL是一个比较有名的实现方案。

2. 中间件封装

   ​		独立开发一套系统，有兼容的SQL访问协议，通过独立的系统进行读写分离。在外部接口看来这个中间件与具体的数据库没有什么区别。这种模式具备以下几种特点：

   - 编程语言无关性，对外提供统一的SQL接口
   - 需要支持不同数据库的特殊SQL语法与对应的网络协议
   - 主从节点上数据的读写压力会放到中间件上，所以中间件的可能会成为性能瓶颈
   - 中间件需要感知数据库主从节点的状态变化，将这种变化与业务代码进行隔离

##### 1.1.2  分库分表

​		读写分离分散了访问压力，但是没有减轻存储压力，数据量过大的情况下，单台数据库服务的存储能力就会成为新的瓶颈。这个瓶颈主要体现在如下几个方面。

- 数据量过大，读写性能会下降。
- 数据量大以后，数据文件的大小会很大，导致数据库备份与恢复的时间会变长。
- 数据文件的大小越大，极端情况下丢失数据的风险就越高。

###### 1.1.2.1  分库

​		分库是指按照业务模块将数据分散到不同的数据库服务器。虽然业务分库可以减轻数据库的存储与访问压力，但是也会引入其他的问题。

- join  操作，原先在一个数据库执行join操作就可以获取的数据，现在需要调用两个接口访问两个数据库获取到数据以后在代码中进行合并。
- 事务问题，数据库跨库以后，原先的事务性难以保证，虽然有各种分布式事务框架，但是分布式事务框架本身的性能不一定好。
- 成本问题，业务分库之后，导致需要的数据库服务器数量增加，提高了采购成本。

###### 1.1.2.2  分表

1. 水平分表

   ​		是指按照按照行的维度进行数据分表，比如将1-100行放入表A，将101-200行放到表B。水平分表会面临更大的复杂性。

   - 路由，需要采用一个路由算法用于确定某一条数据需要写入那一张目标表中。
     - 路由算法
       - 范围路由：不同的分段落入不同的数据库表中，例如对主键ID进行分段，0-1000放入一张表，1001-2000放入另外一张表中。该方案的优点是可以平滑的扩充新的表，但是缺点也很明显，主要的缺点就是数据的分布可能不均匀，一张表的数据只有1000，但是其他表的数据量可能有100000。但是如果选择的分段字段为表的自增主键Id字段，那么数据拆分可以确保比较均匀，但是随着时间的流水，数据会产生倾斜，导致某个范围数据量很大，依然难以避免数据分布不均。
       - Hash路由：采用固定的Hash算法，对某一列或者几个列属性上的值进行运算，参照最后的hash结果确定，数据最终需要落入到哪张表中。例如可以通过user_id %10【假如计划分成10张表】来将对应的数据放到具体的表中。采用这种方案的时候，初始分表的数量需要确定好，表数量太多维护比较麻烦，表数量太少有可能依旧存在单表性能问题。该方案的有点是数据分散的比较均匀，但是扩充比较麻烦，需要对所有的数据进行重新hash然后放到对应的位置上去。
       - 路由表：配置一张单独的路由表，记录表记录Id字段到具体表名的映射关系。这种方式的主要确定是需要查询两次，影响性能；另外随着分表的数据量大，路由表本身的数据量也会变大，那么路由表就又会成为新的性能瓶颈。
       
     - join  操作：

       ​		分表后，数据分散在不同的表中，需要在业务代码或者中间件中对不同分表的数据查询结果进行汇总。

     - count 操作：

       - 累加法：将各个分表的数据count之后进行累加，最终获取到原表的count结果值。
       - 记录数表：新建一张表，包含两个字段table_name字段存储表名，table_count字段存储该表总的记录数，每次只需要查询该表就可以获取对应的表记录总数，虽然读取性能好度了，但是数据更新的复杂度上升了，原表每插入一条记录，就需要在记录数表更新一下总数。

     - order by：需要在业务代码或者中间件中分别对各个分表的查询结果进行汇总排序。

##### 1.1.3    主从与主备

​		主从架构中，从节点需要提供业务功能；而在主备模式中，备节点不需要提供业务功能只需要提供数据备份的功能。例如在数据库主从架构部署模式中，数据库从节点需要对外提供数据读取的功能。

#### 1.2    高性能NOSQL

##### 1.2.1 	关系型数据库缺点：

- 无法存储数据结构
- 数据库的schema扩展麻烦
- 数据库在大数据情况下I/O比较高，数据库存储的是整行数据，进行操作的时候需要将整行的数据都读取出来。
- 全文搜索功能比较弱，依赖于数据库的like操作，没法实现分词搜索的功能。

##### 1.2.2    NOSQL分类

- K-V存储：以Redis为例，解决无法存储数据结构的问题。

- 文档数据库：以MongoDB为例，解决关系数据库强schema约束的问题。

- 列式数据库：以Hbase为例，解决关系型数据库大数据场景下的I/O问题。

  ​		行式数据库同时读取多个列效率高，能够同时对一行中多个列进行操作，保证了针对行数据写操作的原子性与一致性。列式数据库如果只读取一列数据进行统计的话，I/O减少，另外列式存储还有更高的压缩比。列式存储一般用户离线的大数据分析与统计场景中，以为这种场景主要是针对部分列单列进行操作，且数据写入之后就无需再更新删除。

- 全文搜索引擎：以elasticsearch为例，解决关系型数据库的全文搜索性能问题。

  ​		全文搜索下索引的劣势，全文搜索的条件可以随意排列组合，如果按照对应的排列组合分别构建索引，那么索引的数量会比较多；全文搜索的模糊匹配只能使用like查询，like查询可能会进行全表扫描，效率可能会很低。

#### 1.3    高性能缓存架构

##### 	13.1	缓存热点

​		对于一些热点数据，如果大部分的请求都命中同一份缓存数据，那么这份缓存数据所在的机器压力就会很大。对应的解决方案就是将缓存数据复制多份并存储在不同的机器上，来将请求分散到不同的机器上从而减轻缓存热点导致的单台服务器缓存压力。但是需要注意缓存数据的多份副本不要设置成统一的过期时间，否则可能会出现所有的缓存副本同时失效，从而引发缓存雪崩效应。正确的做法是设定一个过期时间的范围，不同的缓存副本的过期时间是在指定范围的随机值。



### 2，高可用

#### 2.1	CAP理论

​		在一个相互连接并共享数据的分布式系统中，当涉及读写操作的时候，只能保证一致性，可用性，分区容错性三者中的两个，另外一个必须被牺牲。正常情况下只能选择CP或者AP因为一定需要有P，网络分区是不可避免会发生的。

##### 2.1.1	一致性（Consistency）

​		对于某个指定的客户端来说，读操作能够返回最新的写操作结果。

##### 2.1.2	可用性（Availability）

​		非故障的节点在合理的时间内返回合理的响应。

##### 2.1.3	分区容忍性 （Partition Tolerance）

​		当出现网络分区后，系统能够继续履行职责。

#### 2.2	CAP注意事项

- CAP关注的是数据而不是系统，进行架构设计的时候需要将系统内的数据按照不同的场景和要求进行分类，每类数据应该选择不同的

的策略，CP或者AP。

- CAP是忽略网络延迟的，所以无法做到严格意义上的一致性，如果业务上对于一致性有很强的要求，只能选择CA。忽略网络分区，也就是数据不进行共享，一份数据只存在于一个节点上。
- 既要考虑分区发生时候选择CP还是AP，又要考虑分区没有发生的时候如何保证CA。
- 放弃不等于什么都不做，需要为分区恢复后做准备。

### 3，可扩展性

### 4，低成本

### 5，安全

### 6，规模

## 架构设计的流程：

### 1，识别复杂度

​		将主要的复杂度问题列出来，然后根据业务，技术，团队等综合情况进行排序，优先结局当前面临的最主要的复杂度问题。可以按照复杂度的来源依次考虑问题。

### 2，设计备选方案

​		选择3-5个备选方案，备选方案的差距需要比较明显，备选方案使用的技术不要只局限与自己熟悉的技术。应该快速知道简单，合适的技术方案，另外对于备选方案的设计也不需要太详细，不需要再备选方案上投入太多的时间，避免颠倒主次，对于备选方案的设计更主要的是关注技术设计而不是技术细节。

### 3，评估与选择备选方案

​		列出需要关注的质量属性点，然后分别从这些质量属性的维度与评估每一个方案，最后再挑选出最适合当时情况的最优方案。

​		常见的方案属性质量点：性能，可用性，硬件成本，项目投入，复杂度，安全性，可拓展性，开发周期等。

​		在选择的时候需要针对不同的质量属性点设计不同的优先级，按照优先级依次评估不同的方案是否满足自己的设计。

### 4，详细方案设计

​		需要对备选方案的关键细节有较深入的了解，通过分步骤，分阶段，分系统等方式，尽量降低方案的复杂度，对于复杂的方案可以考虑通过设计团队的方式进行设计。

#### 	

